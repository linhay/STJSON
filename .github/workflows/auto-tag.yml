name: Auto Tag after Swift

on:
  workflow_run:
    workflows: ["Swift"]
    types:
      - completed
    branches:
      - main
      - master

permissions:
  contents: write

jobs:
  tag:
    if: ${{ github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.event == 'push' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.workflow_run.head_sha }}

      - name: Create and push tag
        id: tagger
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          HEAD_SHA: ${{ github.event.workflow_run.head_sha }}
        run: |
          set -euo pipefail

          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          SEMVER_RE='^v?[0-9]+\.[0-9]+\.[0-9]+$'

          # If this commit already has a semver tag, do nothing (idempotent).
          if git tag --points-at HEAD | grep -Eq "${SEMVER_RE}"; then
            EXISTING_TAG=$(git tag --points-at HEAD | grep -E "${SEMVER_RE}" | sort -V | tail -n 1 || true)
            echo "HEAD already has a semver tag (${EXISTING_TAG}). Skipping."
            echo "action=skipped" >> "$GITHUB_OUTPUT"
            echo "tag=${EXISTING_TAG}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Find latest semver tag (supports both v1.2.3 and 1.2.3) and bump patch (+1).
          # The next tag will keep the same prefix style as the latest tag.
          LAST_TAG=$(git tag --list | grep -E "${SEMVER_RE}" | sort -V | tail -n 1 || true)

          if [[ -z "${LAST_TAG}" ]]; then
            PREFIX="v"
            MAJOR=0
            MINOR=0
            PATCH=0
          else
            PREFIX=""
            if [[ "${LAST_TAG}" == v* ]]; then
              PREFIX="v"
            fi
            IFS='.' read -r MAJOR MINOR PATCH <<< "${LAST_TAG#v}"
          fi

          PATCH=$((PATCH + 1))
          TAG="${PREFIX}${MAJOR}.${MINOR}.${PATCH}"

          # If the next tag already exists (e.g. concurrent runs), keep bumping until free.
          while git rev-parse -q --verify "refs/tags/${TAG}" >/dev/null; do
            PATCH=$((PATCH + 1))
            TAG="${PREFIX}${MAJOR}.${MINOR}.${PATCH}"
          done

          echo "Creating tag: ${TAG}"
          git tag -a "${TAG}" -m "Auto tag for ${GITHUB_REPOSITORY}@${HEAD_SHA}"
          git push origin "${TAG}"

          echo "action=created" >> "$GITHUB_OUTPUT"
          echo "tag=${TAG}" >> "$GITHUB_OUTPUT"

      - name: Notify Bark
        if: always()
        env:
          BARK_HOST: https://api.day.app
          BARK_KEY: ${{ secrets.BARK_KEY }}
          ACTION: ${{ steps.tagger.outputs.action }}
          TAG: ${{ steps.tagger.outputs.tag }}
          STATUS: ${{ job.status }}
          HEAD_SHA: ${{ github.event.workflow_run.head_sha }}
        run: |
          set -euo pipefail

          if [[ -z "${BARK_KEY:-}" ]]; then
            echo "BARK_KEY is not configured. Skipping Bark notification."
            exit 0
          fi

          ACTION="${ACTION:-unknown}"
          TAG="${TAG:-}"

          # Bark uses the path segment as title; avoid spaces/special chars.
          TITLE="SKIntelligence-${ACTION}-${TAG:-no-tag}"
          BODY=$(printf 'repo=%s\nsha=%s\nstatus=%s' "$GITHUB_REPOSITORY" "$HEAD_SHA" "$STATUS")

          # Do not fail the workflow if notification fails.
          curl -fsS -G "${BARK_HOST}/${BARK_KEY}/${TITLE}" \
            --data-urlencode "body=${BODY}" \
            --data-urlencode "group=github" \
            || true
